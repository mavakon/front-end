<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Family Hub – Weather</title>
  <link href="https://fonts.cdnfonts.com/css/cocon" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>

  </style>
</head>
<body>
<div class="layout">
  <aside class="sidebar" role="region" aria-label="Main menu">
    <header class="sidebar-header">
      <h2>Menu</h2>
    </header>
    <nav class="menu-container" aria-label="Site navigation">
      <ul class="menu-list">
        <li><a href="index.html">Home</a></li>
        <li><a href="weather.html">Weather</a></li>
        <li><a href="wishlist.html">Wishlist</a></li>
        <li><a href="plans.html">Plans</a></li>
        <li><a href="about.html">About</a></li>
      </ul>
    </nav>
  </aside>

  <main class="content">
    <img src="images/logo.png" alt="Family Hub Logo" class="logo">
    <header class="page-header">
      <h1>5-Day Weather Forecast</h1>
    </header>
    <div id="weather-root"></div>
  </main>
</div>

<!-- React Weather App -->
<script type="text/babel">
  let API_KEY = '';
  const FORECAST_URL = 'https://api.openweathermap.org/data/2.5/forecast';
  const TIMEOUT_MS = 10000;

  // Fetch API key from server
  fetch('/api/weather-key')
    .then(response => response.json())
    .then(data => {
      API_KEY = data.key;
    })
    .catch(error => {
      console.error('Error fetching API key:', error);
    });

  class WeatherService {

    static async fetchWithTimeout(url, options = {}, timeout = TIMEOUT_MS) {
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), timeout);

      try {
        const response = await fetch(url, {
          ...options,
          signal: controller.signal
        });

        clearTimeout(id);
        return response;
      } catch (error) {
        clearTimeout(id);
        if (error.name === 'AbortError') {
          throw new Error('Request timeout. Please try again later.');
        }
        throw error;
      }
    }

    static async getForecastWeather(city, units = 'metric', retryCount = 0) {
      const MAX_RETRIES = 2;

      try {
        const url = `${FORECAST_URL}?q=${city}&units=${units}&appid=${API_KEY}`;

        const response = await this.fetchWithTimeout(url);

        if (!response.ok) {
          const errorText = await response.text().catch(() => 'Unknown error');
          if (response.status === 404) {
            throw new Error('City not found. Please check the city name and try again.');
          } else if (response.status === 401) {
            throw new Error('API key is invalid. Please check your API key.');
          } else if (response.status === 429) {
            throw new Error('Too many requests. Please try again later.');
          } else {
            throw new Error(`Weather API error (${response.status}): ${errorText}`);
          }
        }

        const data = await response.json();

        const dailyForecasts = {};

        data.list.forEach(item => {
          const date = item.dt_txt.split(' ')[0];

          if (!dailyForecasts[date]) {
            dailyForecasts[date] = {
              date,
              weather: item.weather[0],
              temperature: {
                min: item.main.temp,
                max: item.main.temp,
                morning: null,
                afternoon: null,
                evening: null,
                night: null
              },
              humidity: {},
              pressure: {},
              wind: {
                max: {
                  speed: item.wind.speed,
                  direction: item.wind.deg
                }
              },
              clouds: {
                all: item.clouds.all
              },
              visibility: item.visibility,
              pop: item.pop // Probability of precipitation
            };
          }

          // Extract hour from the time
          const hour = parseInt(item.dt_txt.split(' ')[1].split(':')[0]);

          // Update min/max temperature
          if (item.main.temp < dailyForecasts[date].temperature.min) {
            dailyForecasts[date].temperature.min = item.main.temp;
          }
          if (item.main.temp > dailyForecasts[date].temperature.max) {
            dailyForecasts[date].temperature.max = item.main.temp;
          }

          // Categorize by time of day and update data
          if (hour >= 6 && hour < 12) {
            dailyForecasts[date].temperature.morning = item.main.temp;
            dailyForecasts[date].humidity.morning = item.main.humidity;
            dailyForecasts[date].pressure.morning = item.main.pressure;
          } else if (hour >= 12 && hour < 18) {
            dailyForecasts[date].temperature.afternoon = item.main.temp;
            dailyForecasts[date].humidity.afternoon = item.main.humidity;
            dailyForecasts[date].pressure.afternoon = item.main.pressure;
            // Update weather to use afternoon conditions
            dailyForecasts[date].weather = item.weather[0];
          } else if (hour >= 18 && hour < 24) {
            dailyForecasts[date].temperature.evening = item.main.temp;
            dailyForecasts[date].humidity.evening = item.main.humidity;
            dailyForecasts[date].pressure.evening = item.main.pressure;
          } else {
            dailyForecasts[date].temperature.night = item.main.temp;
            dailyForecasts[date].humidity.night = item.main.humidity;
            dailyForecasts[date].pressure.night = item.main.pressure;
          }
          if (item.wind.speed > dailyForecasts[date].wind.max.speed) {
            dailyForecasts[date].wind.max.speed = item.wind.speed;
            dailyForecasts[date].wind.max.direction = item.wind.deg;
          }
        });

        // Convert to array and sort by date
        return {
          city: {
            name: data.city.name,
            country: data.city.country,
            sunrise: data.city.sunrise,
            sunset: data.city.sunset
          },
          forecasts: Object.values(dailyForecasts).sort((a, b) =>
                  new Date(a.date) - new Date(b.date)
          )
        };
      } catch (error) {
        console.error('Error fetching forecast data:', error);

        // Retry on network errors or timeouts, but not on API errors
        if (retryCount < MAX_RETRIES && 
            (error.message === 'Request timeout. Please try again later.' || 
             error.name === 'TypeError' || // Network error
             error.message.includes('NetworkError'))) {
          console.log(`Retrying forecast request (${retryCount + 1}/${MAX_RETRIES})...`);
          // Wait a bit before retrying (exponential backoff)
          const delay = Math.pow(2, retryCount) * 1000;
          await new Promise(resolve => setTimeout(resolve, delay));
          return this.getForecastWeather(city, units, retryCount + 1);
        }

        throw error;
      }
    }
  }

  function WeatherCard({ data }) {
    if (!data) return null;


    const getDayOfWeek = (dateString) => {
      const options = { weekday: 'long' };
      return new Date(dateString).toLocaleDateString('en-US', options);
    };

    const formatTemp = (temp) => {
      return Math.round(temp);
    };

    const formatPrecipitation = (pop) => {
      if (!pop && pop !== 0) return 'N/A';
      return `${Number(pop * 100).toFixed(0)}%`;
    };

    const getWeatherIconUrl = (iconCode) => {
      return `https://openweathermap.org/img/wn/${iconCode}@2x.png`;
    };

    const calculateAverageHumidity = (humidity) => {
      if (!humidity) return null;

      const values = [];
      if (humidity.morning !== undefined && humidity.morning !== null) values.push(humidity.morning);
      if (humidity.afternoon !== undefined && humidity.afternoon !== null) values.push(humidity.afternoon);
      if (humidity.evening !== undefined && humidity.evening !== null) values.push(humidity.evening);
      if (humidity.night !== undefined && humidity.night !== null) values.push(humidity.night);

      if (values.length === 0) return null;

      const sum = values.reduce((acc, val) => acc + val, 0);
      return Math.round(sum / values.length);
    };

    return (
      <div className="weather-card" style={{ 
        width: '180px', 
        margin: '0 10px', 
        padding: '10px', 
        border: '1px solid #ddd', 
        borderRadius: '8px',
        boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
        fontFamily: 'sans-serif'
      }}>
        <div className="weather-card-header" style={{ textAlign: 'center' }}>
          <h3 style={{ margin: '0 0 5px 0', fontSize: '18px' }}>{getDayOfWeek(data.date)}</h3>
          <p style={{ margin: '0', fontSize: '14px', color: '#666' }}>{new Date(data.date).toLocaleDateString()}</p>
        </div>

        <div className="weather-card-body">
          <div className="weather-main" style={{ 
            display: 'flex', 
            flexDirection: 'column',
            alignItems: 'center', 
            justifyContent: 'center', 
            margin: '10px 0' 
          }}>
            {data.weather && (
              <>
                <img 
                  src={getWeatherIconUrl(data.weather.icon)} 
                  alt={data.weather.description} 
                  style={{ width: '60px', height: '60px' }}
                />
                <div style={{ textAlign: 'center' }}>
                  <div style={{ fontSize: '16px', fontWeight: 'bold', marginBottom: '5px' }}>
                    {formatTemp(data.temperature.max)}° / {formatTemp(data.temperature.min)}°
                  </div>
                  <div style={{ 
                    textTransform: 'capitalize', 
                    fontSize: '14px',
                    whiteSpace: 'nowrap',
                    overflow: 'hidden',
                    textOverflow: 'ellipsis',
                    maxWidth: '160px'
                  }}>
                    {data.weather.description}
                  </div>
                </div>
              </>
            )}
          </div>

          <div className="forecast-details" style={{ fontSize: '13px' }}>
            <div className="detail-item" style={{ display: 'flex', justifyContent: 'space-between', margin: '5px 0' }}>
              <span className="label">Precipitation:</span>
              <span className="value">{formatPrecipitation(data.pop)}</span>
            </div>
            <div className="detail-item" style={{ display: 'flex', justifyContent: 'space-between', margin: '5px 0' }}>
              <span className="label">Humidity:</span>
              <span className="value">{calculateAverageHumidity(data.humidity) || 'N/A'}%</span>
            </div>
            <div className="detail-item" style={{ display: 'flex', justifyContent: 'space-between', margin: '5px 0' }}>
              <span className="label">Wind:</span>
              <span className="value">{data.wind?.max?.speed || 'N/A'} m/s</span>
            </div>
          </div>
        </div>
      </div>
    );
  }

  // Main Weather App Component
  function WeatherApp() {
    const [forecastData, setForecastData] = React.useState(null);
    const [loading, setLoading] = React.useState(true);
    const [error, setError] = React.useState(null);
    const [selectedCity, setSelectedCity] = React.useState('Kyiv');
    const [apiKeyLoaded, setApiKeyLoaded] = React.useState(false);

    // Check if API key is loaded
    React.useEffect(() => {
      const checkApiKey = () => {
        if (API_KEY) {
          setApiKeyLoaded(true);
        } else {
          // If API key is not loaded yet, check again after a short delay
          setTimeout(checkApiKey, 100);
        }
      };

      checkApiKey();
    }, []);

    React.useEffect(() => {
      // Only fetch forecast data if API key is loaded
      if (!apiKeyLoaded) return;

      const fetchForecastData = async () => {
        try {
          setLoading(true);
          setError(null);

          const data = await WeatherService.getForecastWeather(
            selectedCity,
            'metric'
          );

          setForecastData(data);
          setLoading(false);
        } catch (err) {
          console.error('Error fetching forecast data:', err);
          setError('Failed to load weather forecast data. Please try again later.');
          setLoading(false);
        }
      };

      fetchForecastData();
    }, [selectedCity, apiKeyLoaded]); // Re-fetch when selected city changes or API key is loaded

    const handleCityChange = (cityName) => {
      setSelectedCity(cityName);
    };

    const predefinedCities = [
      'Kyiv',
      'London',
      'New York',
      'Tokyo',
      'Paris',
      'Berlin'
    ];

    return (
      <div className="weather-app">
        <div className="location-selector">
          <h3>Select City:</h3>
          <div className="location-buttons">
            {predefinedCities.map((city) => (
              <button
                key={city}
                onClick={() => handleCityChange(city)}
                className={selectedCity === city ? 'active' : ''}
                disabled={loading}
                style={{ 
                  cursor: loading ? 'not-allowed' : 'pointer',
                  opacity: loading ? 0.7 : 1
                }}
              >
                {city}
              </button>
            ))}
          </div>
        </div>

        {loading && (
          <div className="loading-container" style={{
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            padding: '20px',
            margin: '20px 0'
          }}>
            <div className="loader" style={{
              border: '5px solid #f3f3f3',
              borderTop: '5px solid #3498db',
              borderRadius: '50%',
              width: '50px',
              height: '50px',
              animation: 'spin 2s linear infinite',
              marginBottom: '10px'
            }}></div>
            <p>Loading weather forecast data...</p>
            <style>{`
              @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
              }
            `}</style>
          </div>
        )}

        {error && (
          <div className="error-container" style={{
            backgroundColor: '#ffebee',
            border: '1px solid #f44336',
            borderRadius: '4px',
            padding: '15px',
            margin: '20px 0',
            color: '#d32f2f',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            flexDirection: 'column'
          }}>
            <div style={{ 
              fontSize: '24px', 
              marginBottom: '10px',
              display: 'flex',
              alignItems: 'center'
            }}>
              <span style={{ marginRight: '10px' }}>⚠️</span>
              <span>Error</span>
            </div>
            <p className="error-message" style={{ margin: '0', textAlign: 'center' }}>{error}</p>
            <button 
              onClick={() => {
                setError(null);
                setLoading(true);
                // Re-fetch data
                const fetchData = async () => {
                  try {
                    // Check if API key is available
                    if (!API_KEY) {
                      throw new Error('API key is not available. Please refresh the page and try again.');
                    }

                    const data = await WeatherService.getForecastWeather(
                      selectedCity,
                      'metric'
                    );
                    setForecastData(data);
                    setLoading(false);
                  } catch (err) {
                    console.error('Error retrying forecast data:', err);
                    setError(err.message || 'Failed to load weather forecast data. Please try again later.');
                    setLoading(false);
                  }
                };
                fetchData();
              }}
              style={{
                marginTop: '15px',
                padding: '8px 16px',
                backgroundColor: '#f44336',
                color: 'white',
                border: 'none',
                borderRadius: '4px',
                cursor: 'pointer',
                fontWeight: 'bold'
              }}
            >
              Try Again
            </button>
          </div>
        )}

        {!loading && !error && forecastData && (
          <div className="weather-forecast-container" style={{ 
            maxWidth: '1000px', 
            margin: '0 auto', 
            padding: '20px' 
          }}>
            <h2 style={{ 
              textAlign: 'center', 
              marginBottom: '20px',
              color: '#333'
            }}>
              {forecastData.city.name}, {forecastData.city.country} - 5-Day Forecast
            </h2>
            <div className="weather-cards-container" style={{ 
              display: 'flex', 
              flexWrap: 'wrap',
              justifyContent: 'center',
              gap: '15px'
            }}>
              {forecastData.forecasts.slice(0, 5).map((dayForecast, index) => (
                <WeatherCard 
                  key={dayForecast.date} 
                  data={{
                    ...dayForecast,
                    name: forecastData.city.name,
                    country: forecastData.city.country,
                    sunrise: forecastData.city.sunrise,
                    sunset: forecastData.city.sunset
                  }} 
                />
              ))}
            </div>
          </div>
        )}
      </div>
    );
  }

  const container = document.getElementById('weather-root');
  const root = ReactDOM.createRoot(container);
  root.render(<WeatherApp />);
</script>
</body>
</html>
